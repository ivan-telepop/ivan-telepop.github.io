---
title: "Алгоритм Эдсгера Дейкстры. "
publishedAt: "2024-11-11"
summary: "Алгоритмы на графах"
tags: "алгоритмы, дейкстра, python"
---


Алгоритмы это важно ! Возможно их не так часто приходится применять на практике, 
но этот скилл просто должен быть у каждого кто кодит. 
Это константы, догма и библия, правила дорожного движения. Или еще важнее. 
В общем - очень надо!


---

#### Алгоритм Эдсгера Дейкстры (1959 год) 
или просто "Алгорит Дейкстры"


Допустим что мы имеем:
Направленный (Ориентированный) Ациклический Граф 
или Direct Acyclic Graph как говорят англичане.
Представим в нем ребра, узлы, ноды (как вам удобнее):


```
[Start] >>> [A]
[Start] >>> [B]
[B]   >>>   [A]
[A]   >>> [Finish]
[B]   >>> [Finish]
```

Алгоритм Дейкстры решает задачу поиска кратчайшего пути на 'взвешенных графах'.
То есть когда мы имеем значение - "вес ребра", это может означать практически любые данные, расстояние,
затрачиваемое время, съеденные каллории, потраченый рессурс, и так далее. 

У нас есть ограничения: 

Мы не можем решать этим алгоритмом задачу имея ребра с отрицательным весом. 
Для этого есть другой алгоритм и это совсем другая история. Я думаю чуть позже я напишу о нем.
А пока к решению...



Декомпозиция задачи:

- Найти узел с наименьшим весом.
- Проверить, существует ли путь к соседним узлам "легче".
- Обойти с проверкой по всем узлам (нодам).
- Вычислить итоговый путь.



#### Инициируем Python dict() с нодами.

```
graph = {}
graph['start'] = {}
graph['a'] = {}
graph['b'] = {}
graph['fin'] = {}

```


#### Сам граф и его ребра с весами:
```
graph['start']['a'] = 6
graph['start']['b'] = 2
graph['a']['fin'] = 1
graph['b']['a'] = 3
graph['b']['fin'] = 5

```
- От старта к А 
- От старта к В 
- От А к финишу 
- От В к А 
- От В к финишу 

#### Начальные данные указывающие стоймость пути: 

```
costs = {}
costs['a'] = 6
costs['b'] = 2
costs['fin'] = float('inf')

```

#### Узлы и их родительские узлы:

```
parents = {}
parents['a'] = "start"
parents['b'] = "start"
parents['in'] = None

```

#### Пустой Python List для результирующего маршрута.

```
processed = list()

```

#### Эта функция нам поможет найти самый легкий вес.

```
def find_low_cost(costs): 
    lowest = float('inf') 
    lowest_node = None 
    for node in costs: 
        cost = costs[node]  
        if cost < lowest and node not in processed: 
            lowest = cost
            lowest_node = node
    return lowest_node

```

#### Основной блок кода.

```
node = find_low_cost(costs)
while node is not None:
    cost = costs[node]
    neighbors = graph[node]
    for nei in neighbors.keys():
        new_cost = cost + neighbors[nei]
        if costs[nei] > new_cost:
            costs[nei] = new_cost
            parents[nei] = node
    processed.append(node)
    node = find_low_cost(costs)

```

#### Ну и в самом конце "принтанем" наш результирующий набор.

```
print(processed)

```



